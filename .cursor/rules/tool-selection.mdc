---
globs: lib/tool-selector.ts,types/tool-selector.ts,lib/repl/**/*
alwaysApply: false
---

# Tool Selection System

## Context

The tool selection system implements a ReAct-like iterative loop that uses LLM-generated code to explore and filter tools from a large pool (100-200 tools) down to 0-10 relevant tools. The system spawns a real Node.js child process via IPC, allowing variables to persist naturally across iterations without code transformations.

**Status**: ✅ Fully implemented with IPC-based REPL and clean logging

## Architecture

### Two-Stage Process
1. **ToolSelector** (`lib/tool-selector.ts`): Iteratively generates and executes code lines to select relevant tools
2. **Chat Service** (`lib/chat-service.ts`): Uses selected tools with OpenAI to generate responses and execute wrapped tools

### Core Components
- `selectTools()`: Main entry point, spawns child REPL process and implements iterative loop (max 3 steps, can stop early with 0 tools)
- `prepare_initial_context()`: Async function that fetches categories from database and creates system/user prompts with category list, instructs LLM about REPL persistence and uniform DTO
- `generate_next_script()`: Uses `getModel("toolSelector")` from centralized config to generate code lines and thought (including stop with empty tools)
- `executeLines()`: Executes code lines in child REPL via IPC
- `ReplSession` (`lib/repl/ReplSession.ts`): Spawns real Node.js child process, handles IPC communication
- `repl-child` (`lib/repl/repl-child.ts`): Child process with real REPL and META_TOOLS stubs
- `createReplSession()` (`lib/repl/tools.ts`): Factory function to create REPL with META_TOOLS injected
- META_TOOLS: Database query functions using RAG vector search (see `meta-tools-implementation.mdc`)

## Patterns

### System Prompt Requirements
The system prompt is dynamically generated and includes:
1. **Categories list**: Fetched from database, deduplicated by slug, formatted as "slug (Name), slug (Name), ..."
2. **Uniform DTO structure**: All get_* methods use `GetEntityDto` with all filters (categories, apps, classes, methods, search_queries, top, threshold)
3. **Response format**: JSON with `{ "lines": [...], "thought": { "reasoning": "..." } }`
4. **Critical code generation rules**:
   - Each element in "lines" array MUST be a complete, valid JavaScript statement
   - NEVER split multi-line statements (especially arrays) across multiple "lines" elements
   - NEVER include non-executable content (like `thought: {...}`) in the code
   - Keep array literals on ONE line or split into separate variable assignments
   - The "thought" field is ONLY for JSON response metadata, NOT executable code
5. **LLM instructions**:
   - Early termination: Finish in step 1-2 when possible
   - Conversational detection: Immediately call `finish([])` for greetings/thanks
   - Full JavaScript power: Use map, filter, reduce, regex, conditionals, loops (for/while), etc.
   - **Multiple search queries**: Always use 3-5 synonyms per `search_queries` array: `["APY", "yield", "interest rate", "farming", "returns"]`
   - **Length checks & retry logic**: Always check `methods.length === 0` and retry with broader terms/lower threshold
   - **Loops for iteration**: Use for/while loops to try progressively broader searches or lower thresholds
   - **CRITICAL LOOP SAFETY**: ALL loops MUST have clear exit conditions - NEVER use `while (true)` or `while (results.length === 0)` without counter
   - **Max 30 META_TOOLS calls per execution** - exceeding will abort with error! Use fixed loop limits
   - Safe loop: `for (var i = 0; i < searchTerms.length && results.length < 5; i++)` (bounded + condition)
   - Unsafe loop (NEVER): `while (methods.length === 0) { ... }` (infinite if always empty!)
   - LLM-controlled filtering: Choose `threshold` (0.0-1.0) and `top` based on query complexity
   - Simple queries: threshold 0.4-0.5, top 1-3
   - Complex queries: threshold 0.2-0.3, top 5-10
   - Progressive fallback: Start at threshold 0.4, then 0.3, then 0.2 if empty
   - Category filtering: Use `categories` array with category slugs when relevant
   - AI decides which filters are relevant per method
   - Creative exploration: Mix search strategies, use ask_to_* for verification, branch with if/else
   - Smart logging: Only log counts, slugs, insights (not entire objects)
   - Variable persistence: Use `var` for all declarations (never const/let in REPL)
   - Async awareness: Always await META_TOOLS calls
   - Slug extraction: Use .map(x => x.slug) for subsequent calls
   - NEVER proceed with empty results: Try synonyms, broaden search, use loops to iterate
   - **Use ask_to_* for verification**: After gathering tools, verify capabilities with `ask_to_methods(slugs, "question")`
   - **Verification-based finishing**: If verification PASSES (`check.yes`), call `finish(slugs)`. If FAILS, DON'T finish - continue to step 2 with state preserved
   - **CRITICAL finish() rule**: Always check length before calling finish()
   - **Step 1 with 0 tools**: NEVER call `finish([])` unless it's a conversational query - continue to step 2 instead
   - **Step 2 strategy**: REUSE variables from step 1 (REPL is persistent!), expand with broader searches, lower thresholds (0.2-0.3), higher top (10-15)
   - **Step 3 strategy**: Ultra-simple fallback with generic terms `["data", "api"]`, very low threshold (0.15-0.2), high top (15-20), MUST call finish()
   - **Error handling**: If errors occur, DON'T redo - FIX in next step with different approach, simpler code, or fallbacks: `var x = methods || []`
   - **Pattern**: `if (uniqueSlugs.length > 0) { await finish(uniqueSlugs) }` - if 0 tools in step 1, don't call finish()
   - MANDATORY finish() call: Code with tools found MUST end with `await finish(method_slugs)`

Example patterns:
```typescript
// Multiple queries with length checks and retry (STEP 1)
var apyQueries = ["highest APY", "yield farming", "APY yield", "farming returns", "interest rate"];
var apyMethods = await get_methods({ search_queries: apyQueries, top: 5, threshold: 0.4 });
if (apyMethods.length === 0) { apyMethods = await get_methods({ search_queries: ["yield", "APY", "farming"], top: 5, threshold: 0.3 }); }
if (apyMethods.length === 0) { apyMethods = await get_methods({ search_queries: ["returns", "interest"], top: 5, threshold: 0.2 }); }

// With verification, filtering, and LENGTH CHECK before finish()
var uniqueSlugs = [...new Set(apyMethods.map(m => m.slug))];
if (uniqueSlugs.length > 0) {
  var verified = await ask_to_methods(uniqueSlugs, "Can these provide high APY?");
  var final = verified.yes ? uniqueSlugs : uniqueSlugs.filter(s => /apy|yield|farming/.test(s));
  await finish(final.length > 0 ? final : uniqueSlugs);
}
// If uniqueSlugs.length === 0, don't call finish() - continue to step 2

// Loop-based iterative refinement with length check
var results = [];
var searchTerms = ["bitcoin price", "BTC price", "bitcoin market data", "crypto price"];
for (var i = 0; i < searchTerms.length && results.length < 5; i++) {
  var found = await get_methods({ search_queries: [searchTerms[i]], top: 3, threshold: 0.4 - (i * 0.05) });
  if (found.length > 0) { results.push(...found); }
}
var uniqueSlugs = [...new Set(results.map(m => m.slug))];
if (uniqueSlugs.length > 0) { await finish(uniqueSlugs); }
// If 0 tools found in step 1, don't call finish() - continue to step 2
```

### Valid Response Format Examples

**Creative with multiple queries and retry logic (STEP 1 - with length check)**:
```json
{
  "lines": [
    "var apyQueries = [\"highest APY\", \"yield farming\", \"APY yield\", \"farming returns\", \"interest rate\"]",
    "var apyMethods = await get_methods({ search_queries: apyQueries, top: 5, threshold: 0.4 })",
    "if (apyMethods.length === 0) { apyMethods = await get_methods({ search_queries: [\"yield\", \"APY\", \"farming\"], top: 5, threshold: 0.3 }) }",
    "if (apyMethods.length === 0) { apyMethods = await get_methods({ search_queries: [\"returns\", \"interest\"], top: 5, threshold: 0.2 }) }",
    "var uniqueSlugs = [...new Set(apyMethods.map(m => m.slug))]",
    "if (uniqueSlugs.length > 0) { var verified = await ask_to_methods(uniqueSlugs, \"Can these provide high APY in yield farming?\"); var final = verified.yes ? uniqueSlugs : uniqueSlugs.filter(s => /apy|yield|farming/.test(s)); await finish(final.length > 0 ? final : uniqueSlugs) }"
  ],
  "thought": { "reasoning": "Search with 5 synonyms, progressive fallback, verify, filter if needed. Only finish if tools found - if 0 tools, continue to step 2" }
}
```
Note: If `uniqueSlugs.length === 0` after all searches, DON'T call finish() - let it continue to step 2!

**Multi-concept with progressive fallback (with length check)**:
```json
{
  "lines": [
    "var m1 = await get_methods({ search_queries: [\"TVL increase\", \"TVL growth\", \"TVL trend\", \"total value locked\"], top: 5, threshold: 0.3 })",
    "if (m1.length < 3) { var m1b = await get_methods({ search_queries: [\"TVL\", \"value locked\"], top: 5, threshold: 0.2 }); m1 = [...m1, ...m1b] }",
    "var m2 = await get_methods({ search_queries: [\"APY growth\", \"yield changes\", \"interest rate change\", \"farming returns\"], top: 5, threshold: 0.3 })",
    "if (m2.length < 3) { var m2b = await get_methods({ search_queries: [\"APY\", \"yield\", \"interest\"], top: 5, threshold: 0.2 }); m2 = [...m2, ...m2b] }",
    "var uniqueSlugs = [...new Set([...m1, ...m2].map(x => x.slug))]",
    "if (uniqueSlugs.length > 0) { await finish(uniqueSlugs.slice(0, 10)) }"
  ],
  "thought": { "reasoning": "Search with multiple synonyms each, check length and retry if insufficient, deduplicate, limit to 10. Only finish if tools found" }
}
```

**Step 2 - REUSE variables from step 1 and expand**:
```json
{
  "lines": [
    "var broader = await get_methods({ search_queries: [\"general\", \"common\"], top: 10, threshold: 0.2 })",
    "methods = [...(methods || []), ...broader]",
    "var uniqueSlugs = [...new Set(methods.map(m => m.slug))]",
    "if (uniqueSlugs.length > 0) { await finish(uniqueSlugs.slice(0, 10)) }"
  ],
  "thought": { "reasoning": "Reuse 'methods' from step 1 (REPL is persistent!), add broader search results, deduplicate, finish if found. Don't recreate variables!" }
}
```

**Good - Verification with conditional finish** (step 1):
```json
{
  "lines": [
    "var queries = [\"TVL growth\", \"TVL increase\", \"total value locked trend\", \"protocol TVL change\"]",
    "var methods = await get_methods({ search_queries: queries, top: 5, threshold: 0.4 })",
    "if (methods.length < 3) { var m2 = await get_methods({ search_queries: [\"TVL\", \"total value\"], top: 5, threshold: 0.3 }); methods = [...methods, ...m2] }",
    "var slugs = [...new Set(methods.map(m => m.slug))]",
    "if (slugs.length > 0) { var check = await ask_to_methods(slugs, \"Can these track TVL growth over time?\"); console.log(\"Verified:\", check.yes); if (check.yes) { await finish(slugs) } }"
  ],
  "thought": { "reasoning": "Progressive broadening, verify capabilities. Finish only if verified. If fails or 0 tools, continue to step 2 with state preserved" }
}
```

**Bad - Finishing when verification fails**:
```json
{
  "lines": [
    "var methods = await get_methods({ search_queries: [\"TVL\"], top: 5 })",
    "var check = await ask_to_methods(methods.map(m => m.slug), \"Can these track TVL?\"); await finish(check.yes ? methods.map(m => m.slug) : [])"
  ]
}
```
Problem: Calls finish([]) when verification fails! Should NOT call finish() - let it continue to step 2 where different approaches can be tried with state preserved.

**Step 3 - Ultra-simple fallback to GUARANTEE results**:
```json
{
  "lines": [
    "console.log(\"Step 3 (FINAL): Starting with\", (methods || []).length, \"methods from previous steps\")",
    "var fallback = await get_methods({ search_queries: [\"data\", \"api\", \"information\"], top: 15, threshold: 0.15 })",
    "methods = [...(methods || []), ...fallback]",
    "var final = [...new Set(methods.map(m => m.slug))]",
    "console.log(\"Step 3: Final unique methods:\", final.length)",
    "await finish(final.slice(0, 10))"
  ],
  "thought": { "reasoning": "Final step - keep it simple. Ultra-broad search with low threshold, add to existing, deduplicate, finish with top 10. Use fallback (methods || []) for safety. MUST finish!" }
}
```

### Invalid Response Format Examples (NEVER DO THIS)

**❌ Splitting arrays across lines**:
```json
{
  "lines": [
    "var methods = await get_methods({ search_queries: [\"price\"], top: 3 })",
    "await finish([",
    "  ...methods.map(m => m.slug)",
    "])"
  ]
}
```
This creates syntax errors when lines are executed separately!

**❌ Including metadata in code**:
```json
{
  "lines": [
    "var methods = await get_methods({ search_queries: [\"price\"], top: 3 })",
    "await finish([methods[0].slug])",
    "thought: { \"reasoning\": \"my reasoning\" }"
  ]
}
```
The "thought" field is NOT executable JavaScript - it belongs in the JSON response only!

### Iterative Loop Structure
```typescript
const session = createReplSession(); // Spawns child Node.js process
const executionHistory: ExecutionHistoryItem[] = [];
const maxSteps = 3; // Reduced from 10 - encourages early termination

while (step < maxSteps) {
  const { lines, thought } = await generate_next_script(...);
  
  // Check if finish() was called in REPL
  const finishResult = session.getFinishResult();
  if (finishResult !== null) {
    const toolSlugs = finishResult; // Can be empty for conversational queries
    return fetchMethodsBySlugs(toolSlugs);
  }
  
  const result = await executeLines(session, lines.lines);
  executionHistory.push({ lines, thought, result });
  
  // Step 2 prompt encourages finishing if enough info
  // Step 3 is final step with explicit finish() requirement
}
```

### IPC-Based REPL Execution
- **ReplSession** spawns real Node.js child process at start of `selectTools()`
- Child runs actual Node.js REPL with custom evaluator supporting top-level `await`
- **Top-level await support**: Code with `await` is automatically wrapped in async IIFE
- **Variable persistence**: Variables declared with `await` are assigned to global context for cross-line access
- **Incomplete statement detection**: REPL detects incomplete code (unbalanced brackets, trailing operators) and waits for more input using `repl.Recoverable`
- **Multi-line execution**: Multiple lines are combined and sent as a single block for proper statement completion
- META_TOOLS communicate via IPC to parent process (single Prisma connection)
- Variables persist naturally in child REPL context via VM module
- 2-minute timeout per tool call
- Errors don't break the session
- Clean, minimal logging

### Tool Identification
- **Always use slugs**, never IDs or names
- Slugs are required, unique fields on App/Class/Method models
- ToolSelector returns Method objects fetched by slugs

### META_TOOLS Interface
All META_TOOLS use uniform `GetEntityDto` structure:
- **Search functions**: All accept `GetEntityDto` with filters: `categories?`, `apps?`, `classes?`, `methods?`, `search_queries: string[]`, `top: number`, `threshold?: number`
  - `get_apps(dto: GetEntityDto)`, `get_classes(dto: GetEntityDto)`, `get_methods(dto: GetEntityDto)`, `get_method_details(dto: GetEntityDto)`
  - Category filtering via SQL JOIN with Category table
  - LLM controls all filters - AI decides which are relevant per method
  - LLM chooses threshold/top based on query complexity (simple: 0.4-0.5 threshold, top 1-3; complex: 0.2-0.3 threshold, top 5-10)
- **Ask functions**: LLM-powered Q&A with batch support (ask_to_apps, ask_to_classes, ask_to_methods)
  - Accept arrays of slugs for batch queries
  - Return `{ yes: boolean, no: boolean, answer: string }`
  - Merge context from multiple entities before LLM query
- **Completion function**: `finish(method_slugs: string[])` - MANDATORY call to terminate selection and return tools
  - Can be called at any step (encouraged in step 1-2 when tools are found)
  - **CRITICAL**: Always check length before calling - `if (uniqueSlugs.length > 0) { await finish(uniqueSlugs) }`
  - **Step 1 with 0 tools**: NEVER call `finish([])` unless conversational query - continue to step 2
  - **Conversational queries**: Empty array allowed ONLY for greetings/thanks in step 1
  - **Step 2+ with 0 tools**: If all search strategies exhausted, then call `finish([])`
- All use slugs for entity identification
- See `meta-tools-implementation.mdc` for details

### Smart Logging Philosophy
The agent can work with large datasets but should log selectively:
- **Do log**: Counts, slugs, key insights, yes/no answers
- **Don't log**: Entire objects/arrays (wastes tokens, bloats execution history)
- Principle: Everything logged goes into execution history and costs tokens
- Example good: `console.log("Found:", apps.length, "-", apps.map(a => a.slug))`
- Example bad: `console.log(apps)` or `console.log(JSON.stringify(methods))`

### System Logging
Internal logging with `[tool-selector]` prefix:
- Entry/exit of `selectTools()` with query
- Tool count on completion
- Errors only (no verbose iteration logs)

## Anti-patterns

### Don't Split Multi-line Statements Across "lines" Array Elements
- ❌ Splitting array literals across multiple "lines" elements causes syntax errors
- ❌ Example: `["await finish([", "  ...methods.map(m => m.slug)", "])"]`
- ✅ Keep arrays on one line: `["await finish([...methods.map(m => m.slug)])"]`
- ✅ Or use intermediate variables: `["var slugs = [...methods.map(m => m.slug)]", "await finish(slugs)"]`

### Don't Include Non-executable Content in Code
- ❌ Including `thought: { "reasoning": "..." }` in the "lines" array
- ❌ Including comments or metadata as separate "lines" elements
- ✅ The "thought" field is ONLY in the JSON response, NOT in executable code
- ✅ Each "lines" element must be a complete, valid JavaScript statement

### Don't Use IDs or Names
- ❌ `get_methods_by_id(methodIds: string[])`
- ✅ `get_method_details({ methods: methodSlugs, search_queries: [...], top: N })` (uses slugs in uniform DTO)

### Don't Create Multiple REPL Sessions
- ❌ Creating new session per iteration spawns new child process
- ✅ Create once, reuse throughout all iterations

### Don't Hardcode Tool Lists
- ❌ Return all tools without filtering
- ✅ Use META_TOOLS to iteratively narrow down based on query

### Don't Skip Execution History
- ❌ Generate code without context from previous iterations
- ✅ Always pass `executionHistory` to `generate_next_script()`

### Don't Use Single Queries or Skip Length Checks
- ❌ `var methods = await get_methods({ search_queries: ["APY"], top: 5 })` - only 1 query, no retry
- ❌ `var verified = await ask_to_methods(slugs, "..."); var final = verified.yes ? slugs : []` - gives up if verification fails
- ✅ Use 3-5 synonyms per search: `search_queries: ["APY", "yield", "interest rate", "farming", "returns"]`
- ✅ Always check lengths: `if (methods.length === 0) { /* retry with broader terms */ }`
- ✅ Use loops for iterative refinement when needed
- ✅ Filter results instead of returning empty if verification fails

### Don't Call finish() with 0 Tools in Step 1
- ❌ `await finish(uniqueSlugs)` without checking if `uniqueSlugs.length > 0` in step 1
- ❌ Finishing with empty array in step 1 for non-conversational queries
- ✅ **Always check length before finish()**: `if (uniqueSlugs.length > 0) { await finish(uniqueSlugs) }`
- ✅ **Step 1 with 0 tools**: Don't call finish() - let it continue to step 2
- ✅ **Conversational queries only**: `finish([])` in step 1 ONLY for greetings/thanks
- ✅ **Step 2+ with 0 tools**: If you've tried everything, then call `finish([])`

### Don't Redo Same Thing After Errors
- ❌ **Bad**: Step 1 gets error "methods is not defined" → Step 2 just recreates same search
- ❌ **Bad**: Retry the exact same code that caused the error
- ✅ **Good**: Check if variable exists: `var methods = methods || []`
- ✅ **Good**: Use different search terms or approach after error
- ✅ **Good**: Simplify code if complexity caused the error
- ✅ **Good**: Add fallback values to prevent undefined errors

Example of good error recovery:
```typescript
// Step 1 had error with 'methods' variable
// Step 2 (CORRECT) - Fix it:
var methods = methods || [];  // Fallback if undefined
console.log("Recovered - starting with", methods.length, "methods");
var broader = await get_methods({ search_queries: ["price", "data", "market"], top: 10, threshold: 0.3 });
methods = [...methods, ...broader];
var uniqueSlugs = [...new Set(methods.map(m => m.slug))];
if (uniqueSlugs.length > 0) { await finish(uniqueSlugs); }
```

### Don't Recreate Variables in Step 2 or Step 3
- ❌ `var methods = await get_methods(...)` in step 2 - wipes out step 1 results!
- ✅ `methods = [...methods, ...newResults]` - adds to existing array
- ✅ `methods.push(...newResults)` - appends to existing array
- ❌ Creating new variable names in each step instead of reusing
- ✅ REPL is persistent - variables from previous steps still exist!

## Best Practices

### Performance & Security
- Max 3 iterations (reduced from 10) - encourages early termination
- **Early termination priority**: Aim to finish in step 1 or step 2 when tools are found
- **Length check rule**: NEVER call `finish([])` with 0 tools in step 1 unless conversational query
- Simple queries: typically finish in step 1 with appropriate threshold/top values
- Conversational queries: 0 tools in 1 step via `finish([])` (greetings/thanks only)
- Tool selection queries: If 0 tools found in step 1, continue to step 2 for different approaches
- IPC overhead: ~1-5ms per message
- Single Prisma connection (parent process)
- 2-minute timeout per tool call
- Child process isolation (no direct filesystem/network access)
- All inputs validated before DB queries

### Step-by-Step Strategy
- **Step 1**: Specific, focused searches with threshold 0.4-0.5, multiple synonyms (3-5), progressive fallback
  - If tools found (length > 0): call `finish()` 
  - If no tools (length === 0): DON'T call finish() - continue to step 2
- **Step 2**: REUSE variables from step 1, expand with broader searches
  - Add to existing arrays: `methods = [...methods, ...broader]`
  - Lower thresholds (0.2-0.3), higher top (10-15)
  - Generic terms: `["general", "common", "basic"]`
  - If tools found: call `finish()`
  - If no tools: continue to step 3
- **Step 3 (FINAL)**: Ultra-simple fallback to GUARANTEE results
  - REUSE all variables from steps 1 & 2: `methods = [...(methods || []), ...fallback]`
  - Single ultra-broad search: `["data", "api", "information"]`
  - Very low threshold (0.15-0.2), high top (15-20)
  - Minimal logic - add, deduplicate, finish
  - MUST call `finish()` - last step
- **Error Recovery**: If any step has errors, next step should FIX not REDO
  - Use fallbacks: `var x = methods || []`
  - Different search approach
  - Simpler code

### Logging
- Minimal: query start, tool count, errors only
- Clean production output

### Testing
- Test conversational queries (should return 0 tools in 1 step)
- Test various query types (specific, broad, ambiguous)
- Monitor logs for errors

## Key Types

- `GetEntityDto`: Uniform DTO for all get_* methods: `{ categories?, apps?, classes?, methods?, search_queries: string[], top: number, threshold?: number }`
- `ThoughtDto`: `{ reasoning?: string }`
- `ToolSelectorResult`: Returns `{ tools: Method[], reasoning: string, debugData }`
- Method objects fetched by slugs from `finish()` result for downstream processing
- `finish()` function: `(method_slugs: string[]) => Promise<{ success: boolean }>` - terminates selection process
