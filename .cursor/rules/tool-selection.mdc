---
globs: lib/tool-selector.ts,types/tool-selector.ts,lib/repl/**/*
alwaysApply: false
---

# Tool Selection System

## Context

The tool selection system implements a ReAct-like iterative loop that uses LLM-generated code to explore and filter tools from a large pool (100-200 tools) down to 0-10 relevant tools. The system spawns a real Node.js child process via IPC, allowing variables to persist naturally across iterations without code transformations.

**Status**: ✅ Fully implemented with IPC-based REPL and clean logging

## Architecture

### Two-Stage Process
1. **ToolSelector** (`lib/tool-selector.ts`): Iteratively generates and executes code lines to select relevant tools
2. **Chat Service** (`lib/chat-service.ts`): Uses selected tools with OpenAI to generate responses and execute wrapped tools

### Core Components
- `selectTools()`: Main entry point, spawns child REPL process and implements iterative loop (max 3 steps, can stop early with 0 tools)
- `prepare_initial_context()`: Async function that fetches categories from database and creates system/user prompts with category list, instructs LLM about REPL persistence and uniform DTO
- `generate_next_script()`: Uses `getModel("toolSelector")` from centralized config to generate code lines and thought (including stop with empty tools)
- `executeLines()`: Executes code lines in child REPL via IPC
- `ReplSession` (`lib/repl/ReplSession.ts`): Spawns real Node.js child process, handles IPC communication
- `repl-child` (`lib/repl/repl-child.ts`): Child process with real REPL and META_TOOLS stubs
- `createReplSession()` (`lib/repl/tools.ts`): Factory function to create REPL with META_TOOLS injected
- META_TOOLS: Database query functions using RAG vector search (see `meta-tools-implementation.mdc`)

## Patterns

### System Prompt Requirements
The system prompt is dynamically generated and includes:
1. **Categories list**: Fetched from database, deduplicated by slug, formatted as "slug (Name), slug (Name), ..."
2. **Uniform DTO structure**: All get_* methods use `GetEntityDto` with all filters (categories, apps, classes, methods, search_queries, top, threshold)
3. **Response format**: JSON with `{ "lines": [...], "thought": { "reasoning": "..." } }`
4. **Critical code generation rules**:
   - Each element in "lines" array MUST be a complete, valid JavaScript statement
   - NEVER split multi-line statements (especially arrays) across multiple "lines" elements
   - NEVER include non-executable content (like `thought: {...}`) in the code
   - Keep array literals on ONE line or split into separate variable assignments
   - The "thought" field is ONLY for JSON response metadata, NOT executable code
5. **LLM instructions**:
   - Early termination: Finish in step 1-2 when possible
   - Conversational detection: Immediately call `finish([])` for greetings/thanks
   - Full JavaScript power: Use map, filter, reduce, regex, conditionals, etc.
   - LLM-controlled filtering: Choose `threshold` (0.0-1.0) and `top` based on query complexity
   - Simple queries: threshold 0.4-0.5, top 1-3
   - Complex queries: threshold 0.2-0.3, top 5-10
   - Category filtering: Use `categories` array with category slugs when relevant
   - AI decides which filters are relevant per method
   - Creative exploration: Mix search strategies, ask questions early
   - Smart logging: Only log counts, slugs, insights (not entire objects)
   - Variable persistence: Use `var` for all declarations (never const/let in REPL)
   - Async awareness: Always await META_TOOLS calls
   - Slug extraction: Use .map(x => x.slug) for subsequent calls
   - NEVER proceed with empty results: Try synonyms, broaden search, ask what's available
   - MANDATORY finish() call: Every code section MUST end with `await finish(method_slugs)`

Example patterns:
```typescript
// Simple query with uniform DTO
const methods = await get_methods({ search_queries: ["bitcoin price"], top: 3, threshold: 0.4 });
await finish([methods[0].slug]);

// With category filtering
const apps = await get_apps({ categories: ["market-data"], search_queries: ["price"], top: 5 });
const methods = await get_methods({ apps: apps.map(a => a.slug), search_queries: ["bitcoin"], top: 3 });
await finish(methods.map(m => m.slug));

// Handling empty results
const classes = await get_classes({ apps: appSlugs, search_queries: ["sentiment"], top: 5, threshold: 0.3 });
if (classes.length === 0) {
  const classes2 = await get_classes({ apps: appSlugs, search_queries: ["opinion", "mood"], top: 5, threshold: 0.2 });
}
```

### Valid Response Format Examples

**Simple query (correct)**:
```json
{
  "lines": [
    "var methods = await get_methods({ search_queries: [\"bitcoin price\"], top: 3, threshold: 0.4 })",
    "await finish([methods[0].slug])"
  ],
  "thought": { "reasoning": "Simple query for bitcoin price" }
}
```

**Multi-concept query (correct)**:
```json
{
  "lines": [
    "var m1 = await get_methods({ search_queries: [\"TVL\"], top: 3, threshold: 0.4 })",
    "var m2 = await get_methods({ search_queries: [\"open interest\"], top: 3, threshold: 0.4 })",
    "var allSlugs = [...m1.map(x => x.slug), ...m2.map(x => x.slug)]",
    "await finish(allSlugs)"
  ],
  "thought": { "reasoning": "Multi-concept query" }
}
```

### Invalid Response Format Examples (NEVER DO THIS)

**❌ Splitting arrays across lines**:
```json
{
  "lines": [
    "var methods = await get_methods({ search_queries: [\"price\"], top: 3 })",
    "await finish([",
    "  ...methods.map(m => m.slug)",
    "])"
  ]
}
```
This creates syntax errors when lines are executed separately!

**❌ Including metadata in code**:
```json
{
  "lines": [
    "var methods = await get_methods({ search_queries: [\"price\"], top: 3 })",
    "await finish([methods[0].slug])",
    "thought: { \"reasoning\": \"my reasoning\" }"
  ]
}
```
The "thought" field is NOT executable JavaScript - it belongs in the JSON response only!

### Iterative Loop Structure
```typescript
const session = createReplSession(); // Spawns child Node.js process
const executionHistory: ExecutionHistoryItem[] = [];
const maxSteps = 3; // Reduced from 10 - encourages early termination

while (step < maxSteps) {
  const { lines, thought } = await generate_next_script(...);
  
  // Check if finish() was called in REPL
  const finishResult = session.getFinishResult();
  if (finishResult !== null) {
    const toolSlugs = finishResult; // Can be empty for conversational queries
    return fetchMethodsBySlugs(toolSlugs);
  }
  
  const result = await executeLines(session, lines.lines);
  executionHistory.push({ lines, thought, result });
  
  // Step 2 prompt encourages finishing if enough info
  // Step 3 is final step with explicit finish() requirement
}
```

### IPC-Based REPL Execution
- **ReplSession** spawns real Node.js child process at start of `selectTools()`
- Child runs actual Node.js REPL with custom evaluator supporting top-level `await`
- **Top-level await support**: Code with `await` is automatically wrapped in async IIFE
- **Variable persistence**: Variables declared with `await` are assigned to global context for cross-line access
- **Incomplete statement detection**: REPL detects incomplete code (unbalanced brackets, trailing operators) and waits for more input using `repl.Recoverable`
- **Multi-line execution**: Multiple lines are combined and sent as a single block for proper statement completion
- META_TOOLS communicate via IPC to parent process (single Prisma connection)
- Variables persist naturally in child REPL context via VM module
- 2-minute timeout per tool call
- Errors don't break the session
- Clean, minimal logging

### Tool Identification
- **Always use slugs**, never IDs or names
- Slugs are required, unique fields on App/Class/Method models
- ToolSelector returns Method objects fetched by slugs

### META_TOOLS Interface
All META_TOOLS use uniform `GetEntityDto` structure:
- **Search functions**: All accept `GetEntityDto` with filters: `categories?`, `apps?`, `classes?`, `methods?`, `search_queries: string[]`, `top: number`, `threshold?: number`
  - `get_apps(dto: GetEntityDto)`, `get_classes(dto: GetEntityDto)`, `get_methods(dto: GetEntityDto)`, `get_method_details(dto: GetEntityDto)`
  - Category filtering via SQL JOIN with Category table
  - LLM controls all filters - AI decides which are relevant per method
  - LLM chooses threshold/top based on query complexity (simple: 0.4-0.5 threshold, top 1-3; complex: 0.2-0.3 threshold, top 5-10)
- **Ask functions**: LLM-powered Q&A with batch support (ask_to_apps, ask_to_classes, ask_to_methods)
  - Accept arrays of slugs for batch queries
  - Return `{ yes: boolean, no: boolean, answer: string }`
  - Merge context from multiple entities before LLM query
- **Completion function**: `finish(method_slugs: string[])` - MANDATORY call to terminate selection and return tools
  - Can be called at any step (encouraged in step 1-2 for simple queries)
  - Empty array allowed for conversational queries
- All use slugs for entity identification
- See `meta-tools-implementation.mdc` for details

### Smart Logging Philosophy
The agent can work with large datasets but should log selectively:
- **Do log**: Counts, slugs, key insights, yes/no answers
- **Don't log**: Entire objects/arrays (wastes tokens, bloats execution history)
- Principle: Everything logged goes into execution history and costs tokens
- Example good: `console.log("Found:", apps.length, "-", apps.map(a => a.slug))`
- Example bad: `console.log(apps)` or `console.log(JSON.stringify(methods))`

### System Logging
Internal logging with `[tool-selector]` prefix:
- Entry/exit of `selectTools()` with query
- Tool count on completion
- Errors only (no verbose iteration logs)

## Anti-patterns

### Don't Split Multi-line Statements Across "lines" Array Elements
- ❌ Splitting array literals across multiple "lines" elements causes syntax errors
- ❌ Example: `["await finish([", "  ...methods.map(m => m.slug)", "])"]`
- ✅ Keep arrays on one line: `["await finish([...methods.map(m => m.slug)])"]`
- ✅ Or use intermediate variables: `["var slugs = [...methods.map(m => m.slug)]", "await finish(slugs)"]`

### Don't Include Non-executable Content in Code
- ❌ Including `thought: { "reasoning": "..." }` in the "lines" array
- ❌ Including comments or metadata as separate "lines" elements
- ✅ The "thought" field is ONLY in the JSON response, NOT in executable code
- ✅ Each "lines" element must be a complete, valid JavaScript statement

### Don't Use IDs or Names
- ❌ `get_methods_by_id(methodIds: string[])`
- ✅ `get_method_details({ methods: methodSlugs, search_queries: [...], top: N })` (uses slugs in uniform DTO)

### Don't Create Multiple REPL Sessions
- ❌ Creating new session per iteration spawns new child process
- ✅ Create once, reuse throughout all iterations

### Don't Hardcode Tool Lists
- ❌ Return all tools without filtering
- ✅ Use META_TOOLS to iteratively narrow down based on query

### Don't Skip Execution History
- ❌ Generate code without context from previous iterations
- ✅ Always pass `executionHistory` to `generate_next_script()`

## Best Practices

### Performance & Security
- Max 3 iterations (reduced from 10) - encourages early termination
- **Early termination priority**: Aim to finish in step 1 or step 2
- Simple queries: typically finish in step 1 with appropriate threshold/top values
- Conversational queries: 0 tools in 1 step via `finish([])`
- IPC overhead: ~1-5ms per message
- Single Prisma connection (parent process)
- 2-minute timeout per tool call
- Child process isolation (no direct filesystem/network access)
- All inputs validated before DB queries

### Logging
- Minimal: query start, tool count, errors only
- Clean production output

### Testing
- Test conversational queries (should return 0 tools in 1 step)
- Test various query types (specific, broad, ambiguous)
- Monitor logs for errors

## Key Types

- `GetEntityDto`: Uniform DTO for all get_* methods: `{ categories?, apps?, classes?, methods?, search_queries: string[], top: number, threshold?: number }`
- `ThoughtDto`: `{ reasoning?: string }`
- `ToolSelectorResult`: Returns `{ tools: Method[], reasoning: string, debugData }`
- Method objects fetched by slugs from `finish()` result for downstream processing
- `finish()` function: `(method_slugs: string[]) => Promise<{ success: boolean }>` - terminates selection process
