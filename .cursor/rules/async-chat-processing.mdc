---
globs: app/actions/chat.ts,app/chat/**/chat-page-client.tsx,lib/chat-context.tsx,components/chat/**/*.tsx
alwaysApply: false
---

# Async Chat Processing & Optimistic UI

## Context

Chat messages are processed asynchronously in the background while providing instant UI feedback. The system uses status tracking (PROCESSING/SUCCESS/FAIL) at the Chat level and Server-Sent Events (SSE) to push updates to the UI in real-time.

## Architecture

### Status Tracking
- Chat has `lastStatus` field: `"PROCESSING" | "SUCCESS" | "FAIL" | null`
- Chat has `lastError` field: stores error message on failure
- Status set immediately when message sent, updated when processing completes

### Async Processing Flow
1. User sends message → `createUserMessage` called
2. User message created, chat status set to "PROCESSING"
3. `setImmediate()` triggers background processing
4. Frontend shows optimistic UI immediately (no waiting)
5. Backend processes asynchronously via `processMessageAsync`
6. Status updated to SUCCESS/FAIL when complete

### Real-time Updates via SSE
- Server-Sent Events push updates to client instantly (0-100ms)
- Backend emits events when status/title/messages change
- Frontend receives events via EventSource connection
- No polling intervals needed (90% reduction in HTTP requests)
- See `sse-realtime.mdc` for SSE implementation details

## Patterns

### Creating Messages (Backend)

**Use atomic transactions** to prevent "New Chat" flash:

```typescript
// app/actions/chat.ts
export async function createUserMessage(chatId, content, userId) {
  const isNewChat = !(await prisma.chat.findUnique({ where: { id: chatId } }));
  const title = isFirstMessage ? content.trim() || "New Chat" : undefined;
  
  // Create chat + message atomically
  const { userMessage } = await prisma.$transaction(async (tx) => {
    if (isNewChat) {
      await tx.chat.create({
        data: { id: chatId, userId, title, lastStatus: "PROCESSING" }
      });
    } else {
      await tx.chat.update({
        where: { id: chatId },
        data: { lastStatus: "PROCESSING", ...(title && { title }) }
      });
    }
    
    const userMessage = await tx.chatMessage.create({
      data: { chatId, role: "user", content }
    });
    return { userMessage };
  });
  
  // Emit events after transaction commits
  if (isNewChat) chatEvents.emitChatCreated(userId, chatId, title);
  chatEvents.emitNewMessage(userId, chatId, userMessage.id, "user", content);
  chatEvents.emitStatusChange(userId, chatId, "PROCESSING", null);
  
  setImmediate(() => processMessageAsync(chatId));
  return { success: true, userMessage };
}
```

### Async Processing (Backend)
```typescript
async function processMessageAsync(chatId) {
  try {
    const chatHistory = await getChatMessages(chatId);
    const aiResponse = await generateResponse(chatHistory);
    
    // Create assistant message and update status in transaction
    await prisma.$transaction([
      prisma.chatMessage.create({
        data: { chatId, role: "assistant", content: aiResponse.content }
      }),
      prisma.chat.update({
        where: { id: chatId },
        data: { lastStatus: "SUCCESS", lastError: null }
      })
    ]);
  } catch (error) {
    await prisma.chat.update({
      where: { id: chatId },
      data: { lastStatus: "FAIL", lastError: error.message }
    });
  }
}
```

### Optimistic UI (Frontend)
```typescript
const handleNewMessage = async (message) => {
  setOptimisticMessage({ id: 'temp', content: message, role: 'user' });
  setIsThinking(true);
  updateChatStatusOptimistic(chatId, "PROCESSING");
  
  createUserMessage(chatId, message, userId).then(() => {
    refreshMessages().then(() => setOptimisticMessage(null));
  });
};
```

### Real-time Updates via SSE
```typescript
useChatEvents({ userId, onEvent: handleChatEvent });

const handleChatEvent = useCallback((event: ChatEvent) => {
  switch (event.type) {
    case "chat:status":
      setChats(prev => updateStatus(prev, event.chatId, event.data.status));
      if (event.chatId === currentChatId) refreshCurrentChat();
      break;
    case "message:new":
      if (event.chatId === currentChatId) refreshCurrentChat();
      refreshSingleChat(event.chatId);
      break;
  }
}, [currentChatId]);
```

## Anti-patterns

### Don't Create Chat in Multiple Steps
```typescript
// ❌ BAD - "New Chat" flash
const chat = await prisma.chat.create({ data: { title: null } });
const message = await prisma.chatMessage.create({ ... });
await prisma.chat.update({ data: { title: content } });

// ✅ GOOD - atomic
await prisma.$transaction(async (tx) => {
  await tx.chat.create({ data: { title: content, lastStatus: "PROCESSING" } });
  await tx.chatMessage.create({ ... });
});
```

### Don't Emit Events Before DB Writes
```typescript
// ❌ BAD
chatEvents.emit(...);
await prisma.update(...);

// ✅ GOOD
await prisma.update(...);
chatEvents.emit(...);
```

### Don't Block UI
```typescript
// ❌ BAD - waits
await createUserMessage(...);

// ✅ GOOD - immediate
createUserMessage(...).then(() => refresh());
return immediately;
```

## Best Practices

- **Atomic operations**: Always use transactions for chat creation (prevents "New Chat" flash)
- **Emit after commits**: Events only after DB writes succeed
- **Optimistic UI**: Show message instantly, don't await backend
- **SSE over polling**: Real-time updates, 90% fewer HTTP requests
- **Single chat refresh**: Use `refreshSingleChat()` over `refreshChats()`
- **Non-blocking**: `setImmediate()` for async processing, return immediately

## Key Files
- `app/actions/chat.ts`: Message creation, async processing, event emission
- `app/chat/[chatId]/chat-page-client.tsx`: SSE event handling, optimistic UI
- `lib/chat-context.tsx`: Chat list state, SSE event routing, optimistic updates
- `components/chat/chat-list.tsx`: Status icons, chat cards
- `lib/chat-events.ts`: Event emitter singleton (see `sse-realtime.mdc`)
- `app/api/chat-events/route.ts`: SSE route handler (see `sse-realtime.mdc`)
