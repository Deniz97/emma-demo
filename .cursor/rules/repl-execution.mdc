---
globs: lib/repl/**/*.ts
alwaysApply: false
---

# REPL Execution System

## Context

Provides persistent Node.js execution environment by spawning a real Node.js child process that communicates via IPC. Variables persist naturally across code executions without transformations.

**Components**: ReplSession (parent), repl-child (child process), ipc-protocol (message types), tools (factory)

## Architecture

Parent-child process model:
- Parent: Spawns child, handles META_TOOLS execution via IPC, captures output
- Child: Real Node.js REPL with custom evaluator supporting top-level `await`
- **Custom evaluator**: Uses Node.js `vm` module for controlled execution with persistent context
- **Top-level await**: Automatically wraps code containing `await` in async IIFE
- **Variable persistence**: Variables declared with `await` are assigned to global context
- **Incomplete statement handling**: Detects incomplete code and throws `repl.Recoverable` to wait for more input
- IPC: 2-minute timeout, fail-fast error handling

## Patterns

### Session Lifecycle

```typescript
const session = createReplSession(); // Spawns child process
try {
  // Multiple lines are combined into a single block for proper execution
  await session.runLines([
    'let apps = await get_apps({ search_queries: ["crypto"], top: 5 })', // Use let, not const! Variables persist across iterations
    'apps.map(a => a.slug)' // Variables persist naturally
  ]);
} finally {
  session.cleanup(); // Always cleanup to kill child process
}
```

**CRITICAL**: Always use `let` for variable declarations (never `const`). Since the REPL persists across iterations, using `const` will cause "Identifier 'varName' has already been declared" errors on subsequent runs.

### Custom Evaluator Implementation

The REPL uses a **minimal** custom evaluator (`customEval`) that:
- **Supports top-level await**: Wraps multi-line code blocks containing `await` in a single async function
- **No code transformation**: Runs LLM-generated code exactly as written
- **Variable persistence**: Variables naturally persist because all lines execute in the same async function scope

```typescript
// Example: Multi-line await block
// Input:
let apps = await get_apps({ search_queries: ["crypto"], top: 5 });
let methods = await get_methods({ apps: apps.map(a => a.slug), top: 3 });

// Wrapped as:
async function(get_apps, get_methods, ...) {
  let apps = await get_apps({ search_queries: ["crypto"], top: 5 });
  let methods = await get_methods({ apps: apps.map(a => a.slug), top: 3 });
}
```

**Key Design Principle**: Minimum invasion - trust Node.js and the LLM to write valid JavaScript. No regex parsing, no code transformation beyond async wrapping.

### IPC Tool Call Flow

```typescript
// Child: Stub sends IPC request
global.get_apps = async (dto) => {
  const id = generateMessageId();
  sendToParent({ type: 'tool_request', id, tool: 'get_apps', args: [dto] });
  return await waitForResponse(id);
};

// Parent: Executes actual tool with uniform DTO
private async handleToolRequest(request) {
  const result = await this.metaTools[request.tool](...request.args);
  this.childProcess.send({ type: 'tool_response', id: request.id, result });
}
```

## Anti-patterns

❌ **Multiple sessions per flow** - Creates new process each time
```typescript
for (const lines of iterations) {
  const session = createReplSession(); // Wrong!
  await session.runLines(lines);
}
```

✅ **Single session reused**
```typescript
const session = createReplSession();
try {
  for (const lines of iterations) {
    await session.runLines(lines); // State persists
  }
} finally {
  session.cleanup();
}
```

❌ **Forgetting cleanup** - Process leaks
❌ **Creating new file instead of using existing** - Use ipc-protocol.ts message types

## Key Benefits

- Real Node.js REPL with custom evaluator
- **Top-level await support**: No need to wrap code in async functions manually
- **Variable persistence**: Variables declared with `await` are accessible across lines via global context
- **Incomplete statement handling**: REPL waits for complete statements before evaluation
- **Multi-line execution**: Multiple lines combined into single block for proper parsing
- Variables persist naturally across iterations via VM context
- Single Prisma connection (parent process)
- Fail-fast error handling (2-minute timeout)
- Type-safe IPC protocol
- Smart output filtering (removes standalone "undefined")

## Smart Logging Philosophy

Agent can work with large datasets but should log selectively:
- **Everything logged goes into execution history** (costs tokens)
- Do log: counts, slugs, key insights
- Don't log: entire objects/arrays (bloats history)
- Example good: `console.log("Found:", apps.length, apps.map(a => a.slug))`
- Example bad: `console.log(apps)` or `console.log(JSON.stringify(data))`

## Message Types

```typescript
// Request: Child → Parent
{ type: 'tool_request', id: string, tool: string, args: unknown[] }

// Response: Parent → Child  
{ type: 'tool_response', id: string, result?: unknown, error?: string }

// Ready: Child → Parent (on startup)
{ type: 'ready' }
```

## Timeouts

- Tool execution: 2 minutes (120 seconds)
- REPL initialization: 10 seconds
- Process cleanup: 5 seconds (SIGTERM → SIGKILL)

## Implementation Details

### Incomplete Statement Detection

The evaluator checks for:
- Unbalanced brackets `()`, braces `{}`, brackets `[]`
- Trailing operators (`+`, `-`, `*`, `/`, `=`, `=>`, etc.)
- Incomplete arrow functions
- Unclosed strings

When incomplete code is detected, throws `repl.Recoverable` error to signal REPL to wait for more input.

### Variable Persistence with Await

When code contains `await`:
1. Variable declarations are detected via regex: `/\b(const|let)\s+(\w+)\s*=\s*await/`
2. Code is wrapped: `(async () => { code; global.varName = varName; })()`
3. Executed in VM context where `global` points to the context object
4. Variables are copied back to REPL context after execution

### Multi-line Code Handling

`runLines()` combines multiple lines into a single block:
```typescript
if (lines.length > 1) {
  const combinedCode = lines.join('\n');
  return [await this.runLine(combinedCode)];
}
```

This ensures incomplete statements spanning multiple lines are handled correctly.
