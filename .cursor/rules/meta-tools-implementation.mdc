---
globs: lib/meta-tools.ts,lib/meta-tools/**/*
alwaysApply: false
---

# META_TOOLS Implementation

## Context

META_TOOLS are database query functions that use RAG (Retrieval-Augmented Generation) vector search and LLM-powered Q&A to help the tool selector find relevant tools. All implementations are organized in separate files under `lib/meta-tools/`.

**Status**: ✅ Fully implemented with logging

## Architecture

### File Structure
```
lib/
  meta-tools.ts                  # Index file (re-exports all functions)
  meta-tools/
    vector-search.ts             # Shared RAG vector search utilities
    llm-query.ts                 # Shared LLM query w/ yes/no detection
    get-apps.ts                  # Search apps by vector similarity
    get-classes.ts               # Search classes by vector similarity
    get-methods.ts               # Search methods by vector similarity
    get-method-details.ts        # Get detailed method info
    ask-to-app.ts                # LLM-powered Q&A about apps (batch)
    ask-to-class.ts              # LLM-powered Q&A about classes (batch)
    ask-to-method.ts             # LLM-powered Q&A about methods (batch)
```

### Two Types of Functions

1. **Search Functions (RAG Vector Search with Uniform DTO)**
   - `get_apps(dto: GetEntityDto)`, `get_classes(dto: GetEntityDto)`, `get_methods(dto: GetEntityDto)`, `get_method_details(dto: GetEntityDto)`
   - All use uniform `GetEntityDto`: `{ categories?, apps?, classes?, methods?, search_queries: string[], top: number, threshold?: number }`
   - Use pgvector cosine similarity on embeddings
   - Search across name, description, and metadata vectors
   - Category filtering via SQL JOIN with Category table (filters by app.categoryId)
   - Return top N results sorted by similarity
   - **LLM-controlled filtering**: All filters optional except `search_queries` and `top` - AI decides which are relevant per method
   - **LLM-controlled threshold**: Default 0.3, but LLM can specify 0.0-1.0 based on query complexity

2. **Ask Functions (LLM-Powered Q&A with Batch Support)**
   - `ask_to_apps(app_slugs: string[], query)`, `ask_to_classes(class_slugs: string[], query)`, `ask_to_methods(method_slugs: string[], query)`
   - Accept arrays of slugs for batch queries
   - Fetch all entities and merge their context
   - Use gpt-3.5-turbo with yes/no detection
   - Return `{ yes: boolean, no: boolean, answer: string, metadata }`

## Patterns

### Vector Search Pattern (Uniform DTO)
```typescript
// In lib/meta-tools/vector-search.ts
export async function searchAppsByVector(
  dto: GetEntityDto  // Uniform DTO with all filters
): Promise<AppDto[]> {
  const { search_queries, top, threshold = 0.3, categories, apps } = dto;
  
  // Generate embeddings for all search queries
  const embeddings = await Promise.all(
    search_queries.map(q => generateEmbedding(q))
  );
  
  // Build dynamic SQL with category/app filtering
  const categoryJoin = categories && categories.length > 0
    ? `INNER JOIN categories cat ON a."categoryId" = cat.id`
    : "";
  const categoryFilter = categories && categories.length > 0
    ? `AND cat.slug = ANY($N::text[])`
    : "";
  const appFilter = apps && apps.length > 0
    ? `AND a.slug = ANY($N::text[])`
    : "";
  
  // Search using pgvector cosine distance across name, description, AND metadata
  // Category filtering via JOIN, all filters optional - AI decides relevance
  const sql = `
    WITH metadata_similarities AS (
      SELECT 
        a.id, a.slug, a.name, a.description,
        1 - (ad."nameVector" <=> $1::vector) as name_sim,
        COALESCE(1 - (ad."descriptionVector" <=> $1::vector), 0) as desc_sim,
        (
          SELECT MAX(1 - (mv::vector <=> $1::vector))
          FROM jsonb_array_elements_text(ad."metadataVectors"::jsonb) mv
        ) as metadata_sim
      FROM apps a
      INNER JOIN app_data ad ON a.id = ad."appId"
      ${categoryJoin}
      WHERE 1=1
      ${appFilter}
      ${categoryFilter}
    )
    SELECT slug, name, description,
      GREATEST(name_sim, desc_sim, COALESCE(metadata_sim, 0)) as similarity
    FROM metadata_similarities
    WHERE name_sim > $3 OR desc_sim > $3 OR COALESCE(metadata_sim, 0) > $3
    ORDER BY similarity DESC
    LIMIT $2
  `;
  
  // Execute for each query, deduplicate, sort by best similarity
  // Return top N unique results filtered by threshold and category/app filters
}
```

### LLM Query Pattern (with Yes/No Detection)
```typescript
// In lib/meta-tools/llm-query.ts
export async function queryLLMWithContext(
  entityType: "app" | "class" | "method" | "apps" | "classes" | "methods",
  entityData: Record<string, any>,
  userQuery: string
): Promise<ResponseDto> {
  // Detect if query is yes/no question
  const isYesNo = isYesNoQuestion(userQuery);
  
  const systemPrompt = `You are a helpful assistant...
    ${isYesNo ? 'Start your answer with "Yes" or "No" clearly.' : ''}`;
  
  const response = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: userPrompt },
    ],
    temperature: 0.7,
  });
  
  const content = response.choices[0]?.message?.content || "";
  const { yes, no } = isYesNo ? extractYesNo(content) : { yes: false, no: false };
  
  return { yes, no, answer: content, metadata: { isYesNoQuestion: isYesNo } };
}
```

### Ask Function Pattern (Batch Support)
```typescript
// In lib/meta-tools/ask-to-method.ts
export async function ask_to_methods(
  method_slugs: string[],  // Now accepts array
  query: string
): Promise<ResponseDto> {
  // 1. Fetch all methods with full context (class, app)
  const methods = await prisma.method.findMany({
    where: { slug: { in: method_slugs } },
    include: { class: { include: { app: true } } },
  });
  
  // 2. Merge context from all methods
  const entityData = {
    methods: methods.map(method => ({
      slug: method.slug,
      name: method.name,
      description: method.description,
      httpVerb: method.httpVerb,
      path: method.path,
      arguments: method.arguments,
      returnType: method.returnType,
      class: { slug: method.class.slug, name: method.class.name },
      app: { slug: method.class.app.slug, name: method.class.app.name }
    })),
    totalMethods: methods.length
  };
  
  // 3. Query LLM with merged context
  return await queryLLMWithContext("methods", entityData, query);
}
```

## Anti-patterns

### Don't Query Without Embeddings
- ❌ Direct text search on database
- ✅ Generate embeddings and use vector similarity

### Don't Use IDs Instead of Slugs
- ❌ `ask_to_methods([methodId], query)`
- ✅ `ask_to_methods([methodSlug], query)`

### Don't Batch Query Single Entities Unnecessarily
- ❌ `ask_to_methods([singleSlug], query)` when you know it's one
- ✅ `ask_to_methods([slug1, slug2, slug3], query)` for genuine batch queries

### Don't Skip Logging
- ❌ Silent execution
- ✅ Log entry, queries, results with `[meta-tools:*]` prefix

### Don't Fetch Without Relations
- ❌ `prisma.method.findUnique({ where: { slug } })`
- ✅ `prisma.method.findUnique({ where: { slug }, include: { class: { include: { app: true } } } })`

### Don't Use Expensive Models for Ask Functions
- ❌ `model: "gpt-4-turbo-preview"` for ask functions
- ✅ `model: "gpt-3.5-turbo"` (cheaper, faster, sufficient)

## Examples

### Using Search Functions in Tool Selector (Uniform DTO)
```typescript
// In generated code executed by tool-selector
// All get_* methods use uniform GetEntityDto - AI decides which filters are relevant

// Simple query: higher threshold for precision, smaller top
const methods = await get_methods({ 
  search_queries: ["bitcoin price"], 
  top: 3, 
  threshold: 0.4 
});
// Returns top 3 methods with similarity > 0.4

// With category filtering
const apps = await get_apps({ 
  categories: ["market-data"], 
  search_queries: ["price"], 
  top: 5 
});

// Complex query: lower threshold for recall, larger top, with filters
const methods = await get_methods({
  apps: apps.map(a => a.slug),
  classes: classes.map(c => c.slug),
  search_queries: ["get price", "fetch data"],
  top: 10,
  threshold: 0.2  // Lower threshold to cast wider net
});

// Filter results further in code if needed
const relevant = methods.filter(m => m.name.toLowerCase().includes("price"));
```

### Using Ask Functions for Clarification (Batch Support)
```typescript
// In generated code executed by tool-selector

// Single method query
const response = await ask_to_methods(
  ["coingecko-prices-get-current-price"],
  "What parameters does this method accept?"
);
console.log(response.answer.substring(0, 100))

// Batch query - multiple methods at once
const methods = await get_methods({ search_queries: ["wallet", "balance"], top: 10 })
const methodSlugs = methods.map(m => m.slug)
const batchResponse = await ask_to_methods(
  methodSlugs,
  "Which of these methods require authentication?"
);
console.log("Auth required:", batchResponse.yes ? "YES" : "NO")
console.log("Details:", batchResponse.answer)

// Batch apps query with category filtering
const apps = await get_apps({ 
  categories: ["nft"], 
  search_queries: ["marketplace"], 
  top: 3 
})
const appResponse = await ask_to_apps(
  apps.map(a => a.slug),
  "Do any of these support ERC-721?"
);
console.log("ERC-721:", appResponse.yes ? "YES" : "NO")
```

### Vector Search with Deduplication (Uniform DTO)
```typescript
// Multiple queries may return same results
// Vector search automatically deduplicates and keeps best similarity score
const results = await searchMethodsByVector({
  apps: ["app-slug"],
  classes: ["class-slug"],
  search_queries: ["get price", "fetch price", "retrieve price"], // similar queries
  top: 5
});
// Returns 5 unique methods, not 15 duplicates
```

## Best Practices

### Vector Search Configuration
- **Uniform DTO**: All get_* methods use `GetEntityDto` with all filters optional except `search_queries` and `top`
- **Category filtering**: Via SQL JOIN with Category table on app.categoryId - filters by category slugs
- **LLM-controlled threshold**: Default 0.3, but LLM can specify 0.0-1.0 based on query complexity
  - Simple queries: 0.4-0.5 (higher precision, fewer results)
  - Medium queries: 0.3-0.4 (balanced)
  - Complex queries: 0.2-0.3 (lower threshold, more recall)
- **LLM-controlled top**: Result count varies by query (1-3 for simple, 5-10 for complex)
- **AI decides filter relevance**: All filters (categories, apps, classes, methods) available to all methods - AI chooses which are relevant
- Search fields: nameVector, descriptionVector, **metadataVectors** (all included)
- **Metadata handling**: metadataVectors is JSON array of vectors - we compute MAX similarity across all metadata vectors
- Use GREATEST() to get best similarity across ALL fields (name, description, and max of metadata)
- Always deduplicate and sort by best similarity
- **Similarity is MAX-based**: Takes the best match across nameVector, descriptionVector, and any metadataVector
- **Filtering strategy**: LLM can also filter results in code after retrieval (e.g., `methods.filter(...)`)

### Embedding Generation
- Use `generateEmbedding()` from `lib/embedding-service.ts`
- Model: "text-embedding-3-small" (1536 dimensions)
- Generate embeddings in parallel for multiple queries
- Cache embeddings if same queries used repeatedly

### LLM Query Configuration
- Model: gpt-3.5-turbo (cheap, fast, good enough)
- Temperature: 0.7 (balanced creativity/accuracy)
- System prompt: Clear instructions about context usage
- User prompt: Include full entity data + user question

### Logging
- Use prefix: `[meta-tools:function-name]`
- Log: Entry with parameters, query count, results count
- Log: Errors with context
- Log: LLM responses (truncated for readability)

### Error Handling
- Return empty arrays for search functions on error
- Return error message in ResponseDto for ask functions
- Always include error in metadata
- Log errors with full context

### Performance
- Parallel embedding generation for multiple queries
- Use database indexes on vector columns (already configured)
- Limit results with `top` parameter
- Deduplicate before sorting (more efficient)

## Type Definitions

### GetEntityDto (Uniform DTO for All Search Functions)
```typescript
type GetEntityDto = {
  categories?: string[];      // Category slugs (e.g., ["market-data", "trading"])
  apps?: string[];            // App slugs
  classes?: string[];         // Class slugs
  methods?: string[];         // Method slugs/IDs
  search_queries: string[];  // Required: search query strings
  top: number;               // Required: max results
  threshold?: number;         // Optional: similarity threshold (default 0.3)
}
```

### Search Function Types (All Use Uniform DTO)
```typescript
get_apps(dto: GetEntityDto): Promise<AppDto[]>
get_classes(dto: GetEntityDto): Promise<ClassDto[]>
get_methods(dto: GetEntityDto): Promise<MethodSummary[]>
get_method_details(dto: GetEntityDto): Promise<MethodDetail[]>
```

### Ask Function Types (Batch Support)
```typescript
ask_to_apps(app_slugs: string[], query: string): Promise<ResponseDto>
ask_to_classes(class_slugs: string[], query: string): Promise<ResponseDto>
ask_to_methods(method_slugs: string[], query: string): Promise<ResponseDto>
```

### Response Types
```typescript
type ResponseDto = {
  yes: boolean;        // True if answer is affirmative (yes/no questions)
  no: boolean;         // True if answer is negative (yes/no questions)
  answer: string;      // Full natural language answer
  metadata?: Record<string, any>;  // Includes isYesNoQuestion flag
}
```

## Database Schema

### Vector Tables
- `app_data`: nameVector, descriptionVector, metadataVectors
- `class_data`: nameVector, descriptionVector, metadataVectors
- `method_data`: nameVector, descriptionVector, metadataVectors

### Category Tables
- `categories`: id, slug, name (unique slug)
- `apps`: categoryId foreign key to categories.id (nullable)

All vector columns are `vector(1536)` with HNSW indexes for fast cosine similarity search.
Category filtering implemented via SQL JOIN: `INNER JOIN categories cat ON a."categoryId" = cat.id WHERE cat.slug = ANY($N::text[])`
