---
globs: lib/meta-tools.ts,lib/meta-tools/**/*
alwaysApply: false
---

# META_TOOLS Implementation

## Context

META_TOOLS are database query functions that use RAG (Retrieval-Augmented Generation) vector search and LLM-powered Q&A to help the tool selector find relevant tools. All implementations are organized in separate files under `lib/meta-tools/`.

**Status**: ✅ Fully implemented with logging

## Architecture

### File Structure
```
lib/
  meta-tools.ts                  # Index file (re-exports all functions)
  meta-tools/
    vector-search.ts             # Shared RAG vector search utilities
    llm-query.ts                 # Shared LLM query w/ yes/no detection
    get-apps.ts                  # Search apps by vector similarity
    get-classes.ts               # Search classes by vector similarity
    get-methods.ts               # Search methods by vector similarity
    get-method-details.ts        # Get detailed method info
    ask-to-app.ts                # LLM-powered Q&A about apps (batch)
    ask-to-class.ts              # LLM-powered Q&A about classes (batch)
    ask-to-method.ts             # LLM-powered Q&A about methods (batch)
```

### Two Types of Functions

1. **Search Functions (RAG Vector Search)**
   - `get_apps()`, `get_classes()`, `get_methods()`, `get_method_details()`
   - Use pgvector cosine similarity on embeddings
   - Search across name, description, and metadata vectors
   - Return top N results sorted by similarity

2. **Ask Functions (LLM-Powered Q&A with Batch Support)**
   - `ask_to_apps(app_slugs: string[], query)`, `ask_to_classes(class_slugs: string[], query)`, `ask_to_methods(method_slugs: string[], query)`
   - Accept arrays of slugs for batch queries
   - Fetch all entities and merge their context
   - Use gpt-3.5-turbo with yes/no detection
   - Return `{ yes: boolean, no: boolean, answer: string, metadata }`

## Patterns

### Vector Search Pattern
```typescript
// In lib/meta-tools/vector-search.ts
export async function searchAppsByVector(
  searchQueries: string[],
  top: number
): Promise<AppDto[]> {
  // Generate embeddings for all search queries
  const embeddings = await Promise.all(
    searchQueries.map(q => generateEmbedding(q))
  );
  
  // Search using pgvector cosine distance across name, description, AND metadata
  const sql = `
    WITH metadata_similarities AS (
      SELECT 
        a.id, a.slug, a.name, a.description,
        1 - (ad."nameVector" <=> $1::vector) as name_sim,
        COALESCE(1 - (ad."descriptionVector" <=> $1::vector), 0) as desc_sim,
        (
          SELECT MAX(1 - (mv::vector <=> $1::vector))
          FROM jsonb_array_elements_text(ad."metadataVectors"::jsonb) mv
        ) as metadata_sim
      FROM apps a
      INNER JOIN app_data ad ON a.id = ad."appId"
    )
    SELECT slug, name, description,
      GREATEST(name_sim, desc_sim, COALESCE(metadata_sim, 0)) as similarity
    FROM metadata_similarities
    WHERE name_sim > 0.3 OR desc_sim > 0.3 OR COALESCE(metadata_sim, 0) > 0.3
    ORDER BY similarity DESC
    LIMIT $2
  `;
  
  // Execute for each query, deduplicate, sort by best similarity
  // Return top N unique results
}
```

### LLM Query Pattern (with Yes/No Detection)
```typescript
// In lib/meta-tools/llm-query.ts
export async function queryLLMWithContext(
  entityType: "app" | "class" | "method" | "apps" | "classes" | "methods",
  entityData: Record<string, any>,
  userQuery: string
): Promise<ResponseDto> {
  // Detect if query is yes/no question
  const isYesNo = isYesNoQuestion(userQuery);
  
  const systemPrompt = `You are a helpful assistant...
    ${isYesNo ? 'Start your answer with "Yes" or "No" clearly.' : ''}`;
  
  const response = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: userPrompt },
    ],
    temperature: 0.7,
  });
  
  const content = response.choices[0]?.message?.content || "";
  const { yes, no } = isYesNo ? extractYesNo(content) : { yes: false, no: false };
  
  return { yes, no, answer: content, metadata: { isYesNoQuestion: isYesNo } };
}
```

### Ask Function Pattern (Batch Support)
```typescript
// In lib/meta-tools/ask-to-method.ts
export async function ask_to_methods(
  method_slugs: string[],  // Now accepts array
  query: string
): Promise<ResponseDto> {
  // 1. Fetch all methods with full context (class, app)
  const methods = await prisma.method.findMany({
    where: { slug: { in: method_slugs } },
    include: { class: { include: { app: true } } },
  });
  
  // 2. Merge context from all methods
  const entityData = {
    methods: methods.map(method => ({
      slug: method.slug,
      name: method.name,
      description: method.description,
      httpVerb: method.httpVerb,
      path: method.path,
      arguments: method.arguments,
      returnType: method.returnType,
      class: { slug: method.class.slug, name: method.class.name },
      app: { slug: method.class.app.slug, name: method.class.app.name }
    })),
    totalMethods: methods.length
  };
  
  // 3. Query LLM with merged context
  return await queryLLMWithContext("methods", entityData, query);
}
```

## Anti-patterns

### Don't Query Without Embeddings
- ❌ Direct text search on database
- ✅ Generate embeddings and use vector similarity

### Don't Use IDs Instead of Slugs
- ❌ `ask_to_methods([methodId], query)`
- ✅ `ask_to_methods([methodSlug], query)`

### Don't Batch Query Single Entities Unnecessarily
- ❌ `ask_to_methods([singleSlug], query)` when you know it's one
- ✅ `ask_to_methods([slug1, slug2, slug3], query)` for genuine batch queries

### Don't Skip Logging
- ❌ Silent execution
- ✅ Log entry, queries, results with `[meta-tools:*]` prefix

### Don't Fetch Without Relations
- ❌ `prisma.method.findUnique({ where: { slug } })`
- ✅ `prisma.method.findUnique({ where: { slug }, include: { class: { include: { app: true } } } })`

### Don't Use Expensive Models for Ask Functions
- ❌ `model: "gpt-4-turbo-preview"` for ask functions
- ✅ `model: "gpt-3.5-turbo"` (cheaper, faster, sufficient)

## Examples

### Using Search Functions in Tool Selector
```typescript
// In generated code executed by tool-selector
const apps = await get_apps(["cryptocurrency", "prices"], 5);
// Returns top 5 apps matching queries

const classes = await get_classes(
  apps.map(a => a.slug),
  ["market data", "historical"],
  3
);
// Returns top 3 classes within those apps

const methods = await get_methods(
  apps.map(a => a.slug),
  classes.map(c => c.slug),
  ["get price", "fetch data"],
  10
);
// Returns top 10 methods matching criteria
```

### Using Ask Functions for Clarification (Batch Support)
```typescript
// In generated code executed by tool-selector

// Single method query
const response = await ask_to_methods(
  ["coingecko-prices-get-current-price"],
  "What parameters does this method accept?"
);
console.log(response.answer.substring(0, 100))

// Batch query - multiple methods at once
const methods = await get_methods([], [], ["wallet", "balance"], 10)
const methodSlugs = methods.map(m => m.slug)
const batchResponse = await ask_to_methods(
  methodSlugs,
  "Which of these methods require authentication?"
);
console.log("Auth required:", batchResponse.yes ? "YES" : "NO")
console.log("Details:", batchResponse.answer)

// Batch apps query
const apps = await get_apps(["NFT", "marketplace"], 3)
const appResponse = await ask_to_apps(
  apps.map(a => a.slug),
  "Do any of these support ERC-721?"
);
console.log("ERC-721:", appResponse.yes ? "YES" : "NO")
```

### Vector Search with Deduplication
```typescript
// Multiple queries may return same results
// Vector search automatically deduplicates and keeps best similarity score
const results = await searchMethodsByVector(
  ["app-slug"],
  ["class-slug"],
  ["get price", "fetch price", "retrieve price"], // similar queries
  5
);
// Returns 5 unique methods, not 15 duplicates
```

## Best Practices

### Vector Search Configuration
- Similarity threshold: 0.3 (lowered from 0.5 for better recall)
- Search fields: nameVector, descriptionVector, **metadataVectors** (all included)
- **Metadata handling**: metadataVectors is JSON array of vectors - we compute MAX similarity across all metadata vectors
- Use GREATEST() to get best similarity across ALL fields (name, description, and max of metadata)
- Always deduplicate and sort by best similarity
- Threshold tuning: 0.5 was too strict, 0.3 captures relevant results while maintaining quality
- **Similarity is MAX-based**: Takes the best match across nameVector, descriptionVector, and any metadataVector

### Embedding Generation
- Use `generateEmbedding()` from `lib/embedding-service.ts`
- Model: "text-embedding-3-small" (1536 dimensions)
- Generate embeddings in parallel for multiple queries
- Cache embeddings if same queries used repeatedly

### LLM Query Configuration
- Model: gpt-3.5-turbo (cheap, fast, good enough)
- Temperature: 0.7 (balanced creativity/accuracy)
- System prompt: Clear instructions about context usage
- User prompt: Include full entity data + user question

### Logging
- Use prefix: `[meta-tools:function-name]`
- Log: Entry with parameters, query count, results count
- Log: Errors with context
- Log: LLM responses (truncated for readability)

### Error Handling
- Return empty arrays for search functions on error
- Return error message in ResponseDto for ask functions
- Always include error in metadata
- Log errors with full context

### Performance
- Parallel embedding generation for multiple queries
- Use database indexes on vector columns (already configured)
- Limit results with `top` parameter
- Deduplicate before sorting (more efficient)

## Type Definitions

### Search Function Types
```typescript
get_apps(search_queries: string[], top: number): Promise<AppDto[]>
get_classes(apps: string[], search_queries: string[], top: number): Promise<ClassDto[]>
get_methods(apps: string[], classes: string[], search_queries: string[], top: number): Promise<MethodSummary[]>
get_method_details(apps: string[], classes: string[], method_ids: string[], search_queries: string[], top: number): Promise<MethodDetail[]>
```

### Ask Function Types (Batch Support)
```typescript
ask_to_apps(app_slugs: string[], query: string): Promise<ResponseDto>
ask_to_classes(class_slugs: string[], query: string): Promise<ResponseDto>
ask_to_methods(method_slugs: string[], query: string): Promise<ResponseDto>
```

### Response Types
```typescript
type ResponseDto = {
  yes: boolean;        // True if answer is affirmative (yes/no questions)
  no: boolean;         // True if answer is negative (yes/no questions)
  answer: string;      // Full natural language answer
  metadata?: Record<string, any>;  // Includes isYesNoQuestion flag
}
```

## Database Schema

### Vector Tables
- `app_data`: nameVector, descriptionVector, metadataVectors
- `class_data`: nameVector, descriptionVector, metadataVectors
- `method_data`: nameVector, descriptionVector, metadataVectors

All vector columns are `vector(1536)` with HNSW indexes for fast cosine similarity search.
